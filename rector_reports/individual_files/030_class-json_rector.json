{
  "file_path": "selected_100_files\\large_500_1000\\030_class-json.php",
  "rector_analysis": {
    "php_version_changes": 6,
    "rules_triggered": [
      "Rector\\Php52\\Rector\\Property\\VarToPublicPropertyRector",
      "Rector\\Php54\\Rector\\Array_\\LongArrayToShortArrayRector",
      "Rector\\Php74\\Rector\\ArrayDimFetch\\CurlyToSquareBracketArrayStringRector",
      "Rector\\Php80\\Rector\\FuncCall\\ClassOnObjectRector",
      "Rector\\Php80\\Rector\\Switch_\\ChangeSwitchToMatchRector",
      "Rector\\Php81\\Rector\\FuncCall\\NullToStrictStringFuncCallArgRector"
    ],
    "changes_by_php_version": {
      "php_52": 1,
      "php_54": 1,
      "php_74": 1,
      "php_80": 2,
      "php_81": 1
    },
    "has_diff": true,
    "diff_line_count": 514
  },
  "analysis_metadata": {
    "rector_version": "2.1.0",
    "analysis_date": "2025-08-31T05:19:27.640043",
    "file_size_kb": 38.8,
    "analysis_type": "version_specific_only"
  },
  "raw_rector_output": {
    "totals": {
      "changed_files": 1,
      "errors": 0
    },
    "file_diffs": [
      {
        "file": "selected_100_files/large_500_1000/030_class-json.php",
        "diff": "--- Original\n+++ New\n@@ -148,9 +148,9 @@\n         $this->_mb_substr            = function_exists('mb_substr');\n     }\n     // private - cache the mbstring lookup results..\n-    var $_mb_strlen = false;\n-    var $_mb_substr = false;\n-    var $_mb_convert_encoding = false;\n+    public $_mb_strlen = false;\n+    public $_mb_substr = false;\n+    public $_mb_convert_encoding = false;\n     \n    /**\n     * convert a string from one UTF-16 char to one UTF-8 char\n@@ -170,30 +170,23 @@\n             return mb_convert_encoding($utf16, 'UTF-8', 'UTF-16');\n         }\n \n-        $bytes = (ord($utf16{0}) << 8) | ord($utf16{1});\n-\n-        switch(true) {\n-            case ((0x7F & $bytes) == $bytes):\n-                // this case should never be reached, because we are in ASCII range\n-                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n-                return chr(0x7F & $bytes);\n-\n-            case (0x07FF & $bytes) == $bytes:\n-                // return a 2-byte UTF-8 character\n-                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n-                return chr(0xC0 | (($bytes >> 6) & 0x1F))\n-                     . chr(0x80 | ($bytes & 0x3F));\n-\n-            case (0xFFFF & $bytes) == $bytes:\n-                // return a 3-byte UTF-8 character\n-                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n-                return chr(0xE0 | (($bytes >> 12) & 0x0F))\n-                     . chr(0x80 | (($bytes >> 6) & 0x3F))\n-                     . chr(0x80 | ($bytes & 0x3F));\n-        }\n-\n-        // ignoring UTF-32 for now, sorry\n-        return '';\n+        $bytes = (ord($utf16[0]) << 8) | ord($utf16[1]);\n+        return match (true) {\n+            // this case should never be reached, because we are in ASCII range\n+            // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n+            (0x7F & $bytes) == $bytes => chr(0x7F & $bytes),\n+            // return a 2-byte UTF-8 character\n+            // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n+            (0x07FF & $bytes) == $bytes => chr(0xC0 | (($bytes >> 6) & 0x1F))\n+                 . chr(0x80 | ($bytes & 0x3F)),\n+            // return a 3-byte UTF-8 character\n+            // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n+            (0xFFFF & $bytes) == $bytes => chr(0xE0 | (($bytes >> 12) & 0x0F))\n+                 . chr(0x80 | (($bytes >> 6) & 0x3F))\n+                 . chr(0x80 | ($bytes & 0x3F)),\n+            // ignoring UTF-32 for now, sorry\n+            default => '',\n+        };\n     }\n \n    /**\n@@ -213,31 +206,24 @@\n         if($this->_mb_convert_encoding) {\n             return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8');\n         }\n-\n-        switch($this->strlen8($utf8)) {\n-            case 1:\n-                // this case should never be reached, because we are in ASCII range\n-                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n-                return $utf8;\n-\n-            case 2:\n-                // return a UTF-16 character from a 2-byte UTF-8 char\n-                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n-                return chr(0x07 & (ord($utf8{0}) >> 2))\n-                     . chr((0xC0 & (ord($utf8{0}) << 6))\n-                         | (0x3F & ord($utf8{1})));\n-\n-            case 3:\n-                // return a UTF-16 character from a 3-byte UTF-8 char\n-                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n-                return chr((0xF0 & (ord($utf8{0}) << 4))\n-                         | (0x0F & (ord($utf8{1}) >> 2)))\n-                     . chr((0xC0 & (ord($utf8{1}) << 6))\n-                         | (0x7F & ord($utf8{2})));\n-        }\n-\n-        // ignoring UTF-32 for now, sorry\n-        return '';\n+        return match ($this->strlen8($utf8)) {\n+            // this case should never be reached, because we are in ASCII range\n+            // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n+            1 => $utf8,\n+            // return a UTF-16 character from a 2-byte UTF-8 char\n+            // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n+            2 => chr(0x07 & (ord($utf8[0]) >> 2))\n+                 . chr((0xC0 & (ord($utf8[0]) << 6))\n+                     | (0x3F & ord($utf8[1]))),\n+            // return a UTF-16 character from a 3-byte UTF-8 char\n+            // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n+            3 => chr((0xF0 & (ord($utf8[0]) << 4))\n+                     | (0x0F & (ord($utf8[1]) >> 2)))\n+                 . chr((0xC0 & (ord($utf8[1]) << 6))\n+                     | (0x7F & ord($utf8[2]))),\n+            // ignoring UTF-32 for now, sorry\n+            default => '',\n+        };\n     }\n \n    /**\n@@ -316,7 +302,7 @@\n                 */\n                 for ($c = 0; $c < $strlen_var; ++$c) {\n \n-                    $ord_var_c = ord($var{$c});\n+                    $ord_var_c = ord($var[$c]);\n \n                     switch (true) {\n                         case $ord_var_c == 0x08:\n@@ -339,12 +325,12 @@\n                         case $ord_var_c == 0x2F:\n                         case $ord_var_c == 0x5C:\n                             // double quote, slash, slosh\n-                            $ascii .= '\\\\'.$var{$c};\n+                            $ascii .= '\\\\'.$var[$c];\n                             break;\n \n                         case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)):\n                             // characters U-00000000 - U-0000007F (same as ASCII)\n-                            $ascii .= $var{$c};\n+                            $ascii .= $var[$c];\n                             break;\n \n                         case (($ord_var_c & 0xE0) == 0xC0):\n@@ -356,10 +342,10 @@\n                                 break;\n                             }\n                             \n-                            $char = pack('C*', $ord_var_c, ord($var{$c + 1}));\n+                            $char = pack('C*', $ord_var_c, ord($var[$c + 1]));\n                             $c += 1;\n                             $utf16 = $this->utf82utf16($char);\n-                            $ascii .= sprintf('\\u%04s', bin2hex($utf16));\n+                            $ascii .= sprintf('\\u%04s', bin2hex((string) $utf16));\n                             break;\n \n                         case (($ord_var_c & 0xF0) == 0xE0):\n@@ -371,11 +357,11 @@\n                             // characters U-00000800 - U-0000FFFF, mask 1110XXXX\n                             // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n                             $char = pack('C*', $ord_var_c,\n-                                         @ord($var{$c + 1}),\n-                                         @ord($var{$c + 2}));\n+                                         @ord($var[$c + 1]),\n+                                         @ord($var[$c + 2]));\n                             $c += 2;\n                             $utf16 = $this->utf82utf16($char);\n-                            $ascii .= sprintf('\\u%04s', bin2hex($utf16));\n+                            $ascii .= sprintf('\\u%04s', bin2hex((string) $utf16));\n                             break;\n \n                         case (($ord_var_c & 0xF8) == 0xF0):\n@@ -387,12 +373,12 @@\n                             // characters U-00010000 - U-001FFFFF, mask 11110XXX\n                             // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n                             $char = pack('C*', $ord_var_c,\n-                                         ord($var{$c + 1}),\n-                                         ord($var{$c + 2}),\n-                                         ord($var{$c + 3}));\n+                                         ord($var[$c + 1]),\n+                                         ord($var[$c + 2]),\n+                                         ord($var[$c + 3]));\n                             $c += 3;\n                             $utf16 = $this->utf82utf16($char);\n-                            $ascii .= sprintf('\\u%04s', bin2hex($utf16));\n+                            $ascii .= sprintf('\\u%04s', bin2hex((string) $utf16));\n                             break;\n \n                         case (($ord_var_c & 0xFC) == 0xF8):\n@@ -404,13 +390,13 @@\n                                 break;\n                             }\n                             $char = pack('C*', $ord_var_c,\n-                                         ord($var{$c + 1}),\n-                                         ord($var{$c + 2}),\n-                                         ord($var{$c + 3}),\n-                                         ord($var{$c + 4}));\n+                                         ord($var[$c + 1]),\n+                                         ord($var[$c + 2]),\n+                                         ord($var[$c + 3]),\n+                                         ord($var[$c + 4]));\n                             $c += 4;\n                             $utf16 = $this->utf82utf16($char);\n-                            $ascii .= sprintf('\\u%04s', bin2hex($utf16));\n+                            $ascii .= sprintf('\\u%04s', bin2hex((string) $utf16));\n                             break;\n \n                         case (($ord_var_c & 0xFE) == 0xFC):\n@@ -422,14 +408,14 @@\n                             // characters U-04000000 - U-7FFFFFFF, mask 1111110X\n                             // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n                             $char = pack('C*', $ord_var_c,\n-                                         ord($var{$c + 1}),\n-                                         ord($var{$c + 2}),\n-                                         ord($var{$c + 3}),\n-                                         ord($var{$c + 4}),\n-                                         ord($var{$c + 5}));\n+                                         ord($var[$c + 1]),\n+                                         ord($var[$c + 2]),\n+                                         ord($var[$c + 3]),\n+                                         ord($var[$c + 4]),\n+                                         ord($var[$c + 5]));\n                             $c += 5;\n                             $utf16 = $this->utf82utf16($char);\n-                            $ascii .= sprintf('\\u%04s', bin2hex($utf16));\n+                            $ascii .= sprintf('\\u%04s', bin2hex((string) $utf16));\n                             break;\n                     }\n                 }\n@@ -456,7 +442,7 @@\n \n                 // treat as a JSON object\n                 if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) {\n-                    $properties = array_map(array($this, 'name_value'),\n+                    $properties = array_map([$this, 'name_value'],\n                                             array_keys($var),\n                                             array_values($var));\n \n@@ -470,7 +456,7 @@\n                 }\n \n                 // treat it like a regular array\n-                $elements = array_map(array($this, '_encode'), $var);\n+                $elements = array_map([$this, '_encode'], $var);\n \n                 foreach($elements as $element) {\n                     if(Services_JSON::isError($element)) {\n@@ -492,7 +478,7 @@\n                         \n                         return ($this->use & SERVICES_JSON_SUPPRESS_ERRORS)\n                         ? 'null'\n-                        : new Services_JSON_Error(get_class($var).\n+                        : new Services_JSON_Error($var::class.\n                             \" toJSON returned an object with a toJSON method.\");\n                             \n                     }\n@@ -502,7 +488,7 @@\n                 \n                 $vars = get_object_vars($var);\n                 \n-                $properties = array_map(array($this, 'name_value'),\n+                $properties = array_map([$this, 'name_value'],\n                                         array_keys($vars),\n                                         array_values($vars));\n \n@@ -551,7 +537,7 @@\n     */\n     function reduce_string($str)\n     {\n-        $str = preg_replace(array(\n+        $str = preg_replace([\n \n                 // eliminate single line comments in '// ...' form\n                 '#^\\s*//(.+)$#m',\n@@ -562,10 +548,10 @@\n                 // eliminate multi-line comments in '/* ... */' form, at end of string\n                 '#/\\*(.+)\\*/\\s*$#Us'\n \n-            ), '', $str);\n+            ], '', (string) $str);\n \n         // eliminate extraneous space\n-        return trim($str);\n+        return trim((string) $str);\n     }\n \n    /**\n@@ -584,7 +570,7 @@\n     {\n         $str = $this->reduce_string($str);\n \n-        switch (strtolower($str)) {\n+        switch (strtolower((string) $str)) {\n             case 'true':\n                 return true;\n \n@@ -595,7 +581,7 @@\n                 return null;\n \n             default:\n-                $m = array();\n+                $m = [];\n \n                 if (is_numeric($str)) {\n                     // Lookie-loo, it's a number\n@@ -609,7 +595,7 @@\n                         ? (integer)$str\n                         : (float)$str;\n \n-                } elseif (preg_match('/^(\"|\\').*(\\1)$/s', $str, $m) && $m[1] == $m[2]) {\n+                } elseif (preg_match('/^(\"|\\').*(\\1)$/s', (string) $str, $m) && $m[1] == $m[2]) {\n                     // STRINGS RETURNED IN UTF-8 FORMAT\n                     $delim = $this->substr8($str, 0, 1);\n                     $chrs = $this->substr8($str, 1, -1);\n@@ -619,7 +605,7 @@\n                     for ($c = 0; $c < $strlen_chrs; ++$c) {\n \n                         $substr_chrs_c_2 = $this->substr8($chrs, $c, 2);\n-                        $ord_chrs_c = ord($chrs{$c});\n+                        $ord_chrs_c = ord($chrs[$c]);\n \n                         switch (true) {\n                             case $substr_chrs_c_2 == '\\b':\n@@ -649,20 +635,20 @@\n                             case $substr_chrs_c_2 == '\\\\/':\n                                 if (($delim == '\"' && $substr_chrs_c_2 != '\\\\\\'') ||\n                                    ($delim == \"'\" && $substr_chrs_c_2 != '\\\\\"')) {\n-                                    $utf8 .= $chrs{++$c};\n+                                    $utf8 .= $chrs[++$c];\n                                 }\n                                 break;\n \n-                            case preg_match('/\\\\\\u[0-9A-F]{4}/i', $this->substr8($chrs, $c, 6)):\n+                            case preg_match('/\\\\\\u[0-9A-F]{4}/i', (string) $this->substr8($chrs, $c, 6)):\n                                 // single, escaped unicode character\n-                                $utf16 = chr(hexdec($this->substr8($chrs, ($c + 2), 2)))\n-                                       . chr(hexdec($this->substr8($chrs, ($c + 4), 2)));\n+                                $utf16 = chr(hexdec((string) $this->substr8($chrs, ($c + 2), 2)))\n+                                       . chr(hexdec((string) $this->substr8($chrs, ($c + 4), 2)));\n                                 $utf8 .= $this->utf162utf8($utf16);\n                                 $c += 5;\n                                 break;\n \n                             case ($ord_chrs_c >= 0x20) && ($ord_chrs_c <= 0x7F):\n-                                $utf8 .= $chrs{$c};\n+                                $utf8 .= $chrs[$c];\n                                 break;\n \n                             case ($ord_chrs_c & 0xE0) == 0xC0:\n@@ -706,25 +692,25 @@\n \n                     return $utf8;\n \n-                } elseif (preg_match('/^\\[.*\\]$/s', $str) || preg_match('/^\\{.*\\}$/s', $str)) {\n+                } elseif (preg_match('/^\\[.*\\]$/s', (string) $str) || preg_match('/^\\{.*\\}$/s', (string) $str)) {\n                     // array, or object notation\n \n-                    if ($str{0} == '[') {\n-                        $stk = array(SERVICES_JSON_IN_ARR);\n-                        $arr = array();\n+                    if ($str[0] == '[') {\n+                        $stk = [SERVICES_JSON_IN_ARR];\n+                        $arr = [];\n                     } else {\n                         if ($this->use & SERVICES_JSON_LOOSE_TYPE) {\n-                            $stk = array(SERVICES_JSON_IN_OBJ);\n-                            $obj = array();\n+                            $stk = [SERVICES_JSON_IN_OBJ];\n+                            $obj = [];\n                         } else {\n-                            $stk = array(SERVICES_JSON_IN_OBJ);\n+                            $stk = [SERVICES_JSON_IN_OBJ];\n                             $obj = new stdClass();\n                         }\n                     }\n \n-                    array_push($stk, array('what'  => SERVICES_JSON_SLICE,\n+                    array_push($stk, ['what'  => SERVICES_JSON_SLICE,\n                                            'where' => 0,\n-                                           'delim' => false));\n+                                           'delim' => false]);\n \n                     $chrs = $this->substr8($str, 1, -1);\n                     $chrs = $this->reduce_string($chrs);\n@@ -748,11 +734,11 @@\n                         $top = end($stk);\n                         $substr_chrs_c_2 = $this->substr8($chrs, $c, 2);\n \n-                        if (($c == $strlen_chrs) || (($chrs{$c} == ',') && ($top['what'] == SERVICES_JSON_SLICE))) {\n+                        if (($c == $strlen_chrs) || (($chrs[$c] == ',') && ($top['what'] == SERVICES_JSON_SLICE))) {\n                             // found a comma that is not inside a string, array, etc.,\n                             // OR we've reached the end of the character list\n                             $slice = $this->substr8($chrs, $top['where'], ($c - $top['where']));\n-                            array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => ($c + 1), 'delim' => false));\n+                            array_push($stk, ['what' => SERVICES_JSON_SLICE, 'where' => ($c + 1), 'delim' => false]);\n                             //print(\"Found split at {$c}: \".$this->substr8($chrs, $top['where'], (1 + $c - $top['where'])).\"\\n\");\n \n                             if (reset($stk) == SERVICES_JSON_IN_ARR) {\n@@ -764,21 +750,21 @@\n                                 // out the property name and set an\n                                 // element in an associative array,\n                                 // for now\n-                                $parts = array();\n+                                $parts = [];\n                                 \n-                               if (preg_match('/^\\s*([\"\\'].*[^\\\\\\][\"\\'])\\s*:/Uis', $slice, $parts)) {\n+                               if (preg_match('/^\\s*([\"\\'].*[^\\\\\\][\"\\'])\\s*:/Uis', (string) $slice, $parts)) {\n  \t                              // \"name\":value pair\n                                     $key = $this->decode($parts[1]);\n-                                    $val = $this->decode(trim(substr($slice, strlen($parts[0])), \", \\t\\n\\r\\0\\x0B\"));\n+                                    $val = $this->decode(trim(substr((string) $slice, strlen((string) $parts[0])), \", \\t\\n\\r\\0\\x0B\"));\n                                     if ($this->use & SERVICES_JSON_LOOSE_TYPE) {\n                                         $obj[$key] = $val;\n                                     } else {\n                                         $obj->$key = $val;\n                                     }\n-                                } elseif (preg_match('/^\\s*(\\w+)\\s*:/Uis', $slice, $parts)) {\n+                                } elseif (preg_match('/^\\s*(\\w+)\\s*:/Uis', (string) $slice, $parts)) {\n                                     // name:value pair, where name is unquoted\n                                     $key = $parts[1];\n-                                    $val = $this->decode(trim(substr($slice, strlen($parts[0])), \", \\t\\n\\r\\0\\x0B\"));\n+                                    $val = $this->decode(trim(substr((string) $slice, strlen((string) $parts[0])), \", \\t\\n\\r\\0\\x0B\"));\n \n                                     if ($this->use & SERVICES_JSON_LOOSE_TYPE) {\n                                         $obj[$key] = $val;\n@@ -789,14 +775,14 @@\n \n                             }\n \n-                        } elseif ((($chrs{$c} == '\"') || ($chrs{$c} == \"'\")) && ($top['what'] != SERVICES_JSON_IN_STR)) {\n+                        } elseif ((($chrs[$c] == '\"') || ($chrs[$c] == \"'\")) && ($top['what'] != SERVICES_JSON_IN_STR)) {\n                             // found a quote, and we are not inside a string\n-                            array_push($stk, array('what' => SERVICES_JSON_IN_STR, 'where' => $c, 'delim' => $chrs{$c}));\n+                            array_push($stk, ['what' => SERVICES_JSON_IN_STR, 'where' => $c, 'delim' => $chrs[$c]]);\n                             //print(\"Found start of string at {$c}\\n\");\n \n-                        } elseif (($chrs{$c} == $top['delim']) &&\n+                        } elseif (($chrs[$c] == $top['delim']) &&\n                                  ($top['what'] == SERVICES_JSON_IN_STR) &&\n-                                 (($this->strlen8($this->substr8($chrs, 0, $c)) - $this->strlen8(rtrim($this->substr8($chrs, 0, $c), '\\\\'))) % 2 != 1)) {\n+                                 (($this->strlen8($this->substr8($chrs, 0, $c)) - $this->strlen8(rtrim((string) $this->substr8($chrs, 0, $c), '\\\\'))) % 2 != 1)) {\n                             // found a quote, we're in a string, and it's not escaped\n                             // we know that it's not escaped becase there is _not_ an\n                             // odd number of backslashes at the end of the string so far\n@@ -803,32 +789,32 @@\n                             array_pop($stk);\n                             //print(\"Found end of string at {$c}: \".$this->substr8($chrs, $top['where'], (1 + 1 + $c - $top['where'])).\"\\n\");\n \n-                        } elseif (($chrs{$c} == '[') &&\n-                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {\n+                        } elseif (($chrs[$c] == '[') &&\n+                                 in_array($top['what'], [SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ])) {\n                             // found a left-bracket, and we are in an array, object, or slice\n-                            array_push($stk, array('what' => SERVICES_JSON_IN_ARR, 'where' => $c, 'delim' => false));\n+                            array_push($stk, ['what' => SERVICES_JSON_IN_ARR, 'where' => $c, 'delim' => false]);\n                             //print(\"Found start of array at {$c}\\n\");\n \n-                        } elseif (($chrs{$c} == ']') && ($top['what'] == SERVICES_JSON_IN_ARR)) {\n+                        } elseif (($chrs[$c] == ']') && ($top['what'] == SERVICES_JSON_IN_ARR)) {\n                             // found a right-bracket, and we're in an array\n                             array_pop($stk);\n                             //print(\"Found end of array at {$c}: \".$this->substr8($chrs, $top['where'], (1 + $c - $top['where'])).\"\\n\");\n \n-                        } elseif (($chrs{$c} == '{') &&\n-                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {\n+                        } elseif (($chrs[$c] == '{') &&\n+                                 in_array($top['what'], [SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ])) {\n                             // found a left-brace, and we are in an array, object, or slice\n-                            array_push($stk, array('what' => SERVICES_JSON_IN_OBJ, 'where' => $c, 'delim' => false));\n+                            array_push($stk, ['what' => SERVICES_JSON_IN_OBJ, 'where' => $c, 'delim' => false]);\n                             //print(\"Found start of object at {$c}\\n\");\n \n-                        } elseif (($chrs{$c} == '}') && ($top['what'] == SERVICES_JSON_IN_OBJ)) {\n+                        } elseif (($chrs[$c] == '}') && ($top['what'] == SERVICES_JSON_IN_OBJ)) {\n                             // found a right-brace, and we're in an object\n                             array_pop($stk);\n                             //print(\"Found end of object at {$c}: \".$this->substr8($chrs, $top['where'], (1 + $c - $top['where'])).\"\\n\");\n \n                         } elseif (($substr_chrs_c_2 == '/*') &&\n-                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {\n+                                 in_array($top['what'], [SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ])) {\n                             // found a comment start, and we are in an array, object, or slice\n-                            array_push($stk, array('what' => SERVICES_JSON_IN_CMT, 'where' => $c, 'delim' => false));\n+                            array_push($stk, ['what' => SERVICES_JSON_IN_CMT, 'where' => $c, 'delim' => false]);\n                             $c++;\n                             //print(\"Found start of comment at {$c}\\n\");\n \n@@ -865,7 +851,7 @@\n     {\n         if (class_exists('pear')) {\n             return PEAR::isError($data, $code);\n-        } elseif (is_object($data) && (get_class($data) == 'services_json_error' ||\n+        } elseif (is_object($data) && ($data::class == 'services_json_error' ||\n                                  is_subclass_of($data, 'services_json_error'))) {\n             return true;\n         }\n@@ -881,9 +867,9 @@\n     function strlen8( $str ) \n     {\n         if ( $this->_mb_strlen ) {\n-            return mb_strlen( $str, \"8bit\" );\n+            return mb_strlen( (string) $str, \"8bit\" );\n         }\n-        return strlen( $str );\n+        return strlen( (string) $str );\n     }\n     \n     /**\n@@ -899,9 +885,9 @@\n             $length = $this->strlen8( $string ) - $start;\n         }\n         if ( $this->_mb_substr ) {\n-            return mb_substr( $string, $start, $length, \"8bit\" );\n+            return mb_substr( (string) $string, $start, $length, \"8bit\" );\n         }\n-        return substr( $string, $start, $length );\n+        return substr( (string) $string, $start, $length );\n     }\n \n }\n",
        "applied_rectors": [
          "Rector\\Php52\\Rector\\Property\\VarToPublicPropertyRector",
          "Rector\\Php54\\Rector\\Array_\\LongArrayToShortArrayRector",
          "Rector\\Php74\\Rector\\ArrayDimFetch\\CurlyToSquareBracketArrayStringRector",
          "Rector\\Php80\\Rector\\FuncCall\\ClassOnObjectRector",
          "Rector\\Php80\\Rector\\Switch_\\ChangeSwitchToMatchRector",
          "Rector\\Php81\\Rector\\FuncCall\\NullToStrictStringFuncCallArgRector"
        ]
      }
    ],
    "changed_files": [
      "selected_100_files/large_500_1000/030_class-json.php"
    ]
  }
}